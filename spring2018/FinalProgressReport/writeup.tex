% Design Document
% CS 461 - CS Senior Capstone
% Fall 2017
% Authors: Connor Christensen, Lily Shellhammer, William Buffum

\documentclass[draftclsnofoot,onecolumn,letterpaper,10pt]{IEEEtran}

% Packaging
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{titling}
\usepackage{color}
\usepackage{listings}
\usepackage{cite}
\usepackage{pdfpages}
\usepackage{pdflscape}
\usepackage{url}
\usepackage{array}
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage{longtable}
\usepackage{standalone}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\geometry{letterpaper, margin=.75in}

% Title page
\title{CS 463 - CS Senior Capstone
	\\Spring 2017
	\\Final Report
}


\author{
	Connor I. Christensen \\
	\texttt{chriconn@oregonstate.edu}
	\\
	Lily M. Shellhammer \\
	\texttt{shellhal@oregonstate.edu}
	\\
	William B. Buffum \\
	\texttt{buffumw@oregonstate.edu}
}

\begin{document}

\begin{titlingpage}
    \maketitle
    \begin{abstract}
			This document details the design and documentation of the Ninkasi Brewhops capstone project.
			Ninkasi Brewing Company is based in Eugene, Oregon, producing and distributing nearly 100,000 barrels of beer each year across the United States and Canada.
			Up until this point, Ninkasi was tracking brewery data using digital and paper spreadsheets.
			Our captone team, comprised of Oregon State Computer Science seniors Connor Christensen, Lily Shellhammer and William Buffum, created a web app for database mangaement to streamline Ninkasi's data collection and tracking.
			We created a database connected to a website for entering fermentation measurements, checking tank statuses, and viewing data over time.
			Our goal is for our site to prevent the errors and delays digital spreadsheet tracking caused.
			The beta version of our site has been delivered to Ninkasi for testing.
			\\
			\textbf{Keywords: Brewing, Operation, Management, Ninkasi, Oregon State University}
    \end{abstract}
		\pagebreak
		\tableofcontents
\end{titlingpage}

\section{Introduction}
	\subsection{Who requested it?}
	Daniel Sharp, Director of Operations, at Ninkasi Brewing Company requested this system.

	\subsection{Why was it requested?}
	Over the last ten years, Ninkasi Brewing Company has exploded in growth.
	With their growth came an influx of data.
	Previously, brewers would manually check all the tanks, write down data points on paper, and transfer those values to an Excel spreadsheet.
	The spreadsheet was then sent around to every individual who needed the values.
	There are several issues with this method: human error, not efficient, and data isn't seen in a timely fashion.
	As Ninkasi continues to grow, these issues will continue to grow.

	\subsection{What is its importance?}
	If Ninkasi cannot maintain consistent batches of beer, then their market share will suffer.

	\subsection{Who was your client?}
	Our client was Daniel Sharp, the Director of Operations at Ninkasi Brewing Company.

	\subsection{Who are the members of your team?}
	The members of our team include: Lily Shellhammer, Connor Christensen, and William Buffum.

	\subsection{What were their roles?}
	Lily Shellhammer was in charge of connecting the client side application to the server side.
	Connor Christensen was in charge of the front end web design.
	William Buffum was in charge of the backend REST API and the database where information is stored.

	\subsection{What was the role of the client?}
	The client helped the development team understand all the business needs of the application.
	Daniel helped us solidify a database structure and gave input on the frontend design.
	
\section{Requirements Document}
	\subsection{Original Document}
	\input{srs}
	\subsection{Modifications}
	The only modifications that were made to the Requirements Document over the course of the year was to remove some sections that were not applicable to our project such as which handshake protocols our project would use.
	\subsection{Updated Gantt Chart}
	\includepdf[pages=1]{OSUNinkasiCapstoneFinal.pdf}
\section{Design Document}
	\subsection{Original Document}
	\input{DesignDoc}
	\subsection{Modifications}
	While the structure of our stack is similar, we have changed some of our technologies.
	We are using Ruby on Rails as our server side langugage instead of Django.
	Our database also has a different layout that works better for rotating batches in tanks.
	We have 5 tables: tanks, batches, batch contents, actions, and tasks.
	Tanks hold information on each tank.
	Batches are stored in tanks and have multiple batch contents which are taken daily, if not more often.
	Actions holds the list of actions that can be taken on tanks, and tasks assigns actions to certain tanks.

\section{Tech Review}
\subsection{Front-End}
This is a comparison of three front end technologies for web design.
\begin{itemize}
	\item Data visualization seeks to find a framework that will aid in the display of information from the database in a user-friendly way.
	\item Styling attempts to cover available options for creating a nice user interface for the project.
	\item Interactive web frameworks outlines the difference between the major pro's and con's of JavaScript frameworks and whether or not they should be used at all.
\end{itemize}

\textbf{Warning:}
The majority of technologies listed in these categories is open source code that builds off other open source modules.
Including code from other open source projects could potentially lead to legal issues.
Each module added into the project comes with a legal agreement that could potentially cause problems for the company later.
These legal agreements may or may not be enforced and they may or may not conflict with other modules in the project.
It is common web development practice to build frameworks from many sub-utilities and packages that are available in the open source community.
As of yet, there is no dedicated team ensuring that all legal agreements agree with each-other and the requirements of the client, and it is up to the client to decide if they want to take steps to guard against the unlikely event that someone stakes a claim against the company based on those licenses.\\






\subsubsection{Data Visualization}

This is an overview of libraries written for data display in web browsers.
Each of these libraries are built using the web language JavaScript to allow for live interaction with the user.
Table 1 shows the code needed to set up a basic bar graph using each library.
These yield approximately the same visual results.
All have the con that they require JavaScript to be enabled and all of them are open source and free.


\textbf{Critera}


	\begin{itemize}
		\item relatively small amounts of code
		\item stable and consistent in its presentation
		\item provide simple charts and graphs like bar charts and plot point graphs
		\item easy for developers to work with
	\end{itemize}


\textbf{Technology}

	\begin{itemize}

		\item{\textit{D3.js}}


			\textbf{About:}

			D3 stands for Data-Driven Documents and it is a powerhouse of a library for data visualization.\cite{d3.org}
			It was created by a team of PhD graduates working out of the Stanford Visualization Group and is essentially the library for creating amazing data visualization.\cite{d3Journal}
			It has a relatively bulky setup, but allows fine grained detail and control over how data is displayed.
			This library is so powerful that it functions more as a library for painting than for graphing.

			\noindent \textbf{Pros:}

			D3 uses SVG's \footnote{\textbf{S}calable \textbf{V}ector \textbf{G}raphics: A visual component defined mathematically. It can scale up or down to any size without loss of image quality.} which allows it to be able to create any 2d shape that can be mathematically defined.
			SVG's do not require JavaScript to work, though D3 can't run without JavaScript enabled.
			The D3 library uses pre-build JavaScript functions to select elements, create SVG objects, and be able to preform a wide number of transformations on them.\cite{d3.org}
			Transformations are just as precise as the drawing abilities and are limited only by the processing power of the computer and the skill of the programmer.
			It uses jQuery and CSS styled selection and modification of content for flexibility and ease of use.
			Objects that are made with D3 are easily syllable with CSS, meaning that data display can inherit styling rules to maintain a consistent look across the platform.
			D3 has a large community and it was built by very intelligent people early on, so it has only gained in popularity since then.\cite{DataVisProCon}
			The majority of data frameworks are built off of D3.
			As such, there are a huge number of online examples.

			\noindent \textbf{Cons:}

			Despite all its good features, the D3 library adds a lot of code to a project, the learning curve is steep, and the code needed to accomplish a task is verbose.\cite{DataVisProCon}
			The code required to set up a bar graph is massive compared to most other frameworks and the time that it takes to learn D3 is an even bigger obstacle.


		\item{\textit{C3.js}}


			\textbf{About:}

			C3 is a package built off D3 and is formatted specifically for creating graphs.

			\noindent \textbf{Pros:}

			It is beautifully simple to create a graph and plug and play really works in this context.
			It has a great set of examples and documentation is readily available.
			It can easily switch between chart types and display multiple chart types mixed in with a single variable changed in the code.\cite{c3.org}
			The amount of things that just work coming out of C3 is impressive, inclusive of the animations that simply show up whenever you load up a graph.

			\noindent \textbf{Cons:}

			Since it is built off D3, C3 requires D3 to be installed, which causes many lines of code to be added to the project.
			There are nearly 10,000 lines of JavaScript in both D3 and C3, bringing in almost 20,000 lines of code for data display.
			The interface is much easier to use, the tradeoff being more limiting in its expressions.


		\item{\textit{Chart.js}}


			\textbf{About:}
			Chart.js is a JavaScript library that allows you to draw different types of charts using the HTML5 canvas element
			\footnote{HTML Canvas: A new web standard that allows web programmers to create computer graphics created and rendered in the browser.}.

			\noindent \textbf{Pros:}

			Chart.js does not use D3 as its underlying code, which means that it is significantly more lightweight as a package.\cite{ChartJS} Like C3, it is very responsive and the documentation is very good.

			\noindent \textbf{Cons:}

			Use of the canvas comes with a few drawbacks, the most common issue being that it cannot scale without loss of quality.
			The HTML5 Canvas specification recommends that authors should not use the canvas element when they have other more suitable means available.\cite{CanvasVsSVG}
			Canvas is good for 3d graphics, but this ability is not beneficial if you simply want a bar graph.
			If you are drawing little details all very close together, canvas is great for that.
			Canvas is not very accessible as it is just drawing pixels and no data can be extracted by assistive technology or bots.

	\end{itemize}



	\textbf{Conclusion}
	It is on our recommendation that C3 be the framework of choice.
	D3 can produce some seriously impressive data visualizations, and chart.js is small and simple, but for the purposes of this project, C3 fits the criteria best.
	As seen in Table 1 in the appendix, the amount of code it takes to create a bar graph is very concise and easy to use, which makes development and maintenance straightforward and produce a small amount of bugs.
	The results are beautiful, informative and user friendly.
	Given the scope of the project, being able to utilize SVG graphing technology in a straightforward and simple way will enhance the product.\\


	\subsubsection{Styling}


		Styling determines how the content is laid out on the page.
		This is what makes layout usable on a variety of screen sizes and the content user friendly.
		There are several methods to apply styling for a webpage, either by building your own, or using a framework that other people have written and dropping your content into their code.

		\textbf{Criteria}
		\begin{itemize}
			\item easily modifiable and maintainable
			\item present a small amount of UI bugs
			\item run quickly
		\end{itemize}


	\textbf{Technology}
		\begin{itemize}
			\item{\textbf{CSS}}

				\textbf{About:}

				Apart from some technologies like SVG's and the HTML5 canvas, CSS is responsible for all website styling.
				It was invented in 1996 and has been one of the three major web languages since then.
				Any method in this styling section is using CSS at some level to deliver it's product.\cite{CSSHistory}

				\noindent \textbf{Pros:}

				Raw CSS is the de facto standard for styling websites.
				There is no other method for changing text color, aligning content on a page, adding drop shadows, etc. other than CSS.
				It is known by all web developers and the community is massive.
				Every bit of code written for styling the web, uses CSS at some point, and because the web always makes client side code like CSS visible to the user, anything you can see is an example you can follow.
				It is easy to debug when you put raw CSS straight into the browser, and if you are writing CSS, you can simply drop that into a browser and it will run without any extra effort.\cite{CSSProCon}

				\noindent \textbf{Cons:}

				Many developers have moved away from writing raw CSS and use a preprocessor or framework, as it is easy to produce difficult to maintain code.
				CSS is much better than the alternative of writing all the styles into the HTML, but CSS still lacks some features that would make organization easier on developers.
				As such, developers working in CSS need to be highly organized if the project gets big enough, and the documentation they write must be clear so other developers can work from what they have built.
				CSS is a syntactically easy language, and in many cases, understanding it is intuitive.
				But there are components to CSS that are complicated and much less intuitive, generally having to do with layout.\cite{CSSProCon}
				CSS requires documentation for future engineers to quickly make sense of the complicated parts of CSS, as writing raw CSS means there is no framework to help standardize how CSS is written.
				For larger projects, CSS developers end up copying and pasting code frequently, which is a bad sign.
				This makes it much easier for inconsistent code to appear and makes it harder to change something on a wide scale.
				Say for example you want to change a single color across your site.
				In CSS, this requires finding every instance of that color and changing it to the new value.

			\item{\textbf{Preprocessors}}

				\textbf{About:}

				Preprocessors are programming languages that utilize some kind of compiler to translate the code into CSS to style web pages.
				They come with the benefit of being able to build new features to make it easier on developers without needing to consult with the W3C\footnote{Listed in the appendix}.
				This allows for flexible work environments which can lead to safer, more efficient and easier coding environments.
				The downside to this freedom is the cost of including another service standing in-between your coding and the finished product.
				It's possible that the preprocessor can develop or contain bugs, and its possible they stop supporting or developing the software.
				That being said, preprocessors have become powerful, widely understood and supported, and have become a tool useful for most projects.

				\noindent \textbf{Pros:}

				Developing with a preprocessor produces the same lightweight code for the user as if the developer had written it straight in CSS. This makes it easier on developers with no sacrifices for the users. Preprocessors provide some really great features like:
				\begin{itemize}
					\item Modular code abilities - developers can separate code into multiple files, which helps with organization. This also means they can include someone else's code into a project without directly pasting it into the custom code for the project.\cite{sass}
					\item Less redundancy in code - preprocessors support the ability to define functions and macros that can reduce the amount of code the developers have to write.
					\item Make it easy to make cascading changes - the ability to define variables makes for simple changes\footnote{CSS is implementing variables in its new standards now, however, this is still slower and not as well supported.}.
					\item Faster development compared to regular CSS - less typing and more organization makes it faster for developers to work.\cite{sass}
					\item Safer code - preprocessors usually automate the long and difficult process of making sure code is compatible with all browsers.
				\end{itemize}

				All the extra steps required by a preprocessor to compile before use are done before deploying, meaning that the client sees no slower performance as a result of the developers using a preprocessor.
				This gives the developers more freedom without a sacrifice for the user.

				\noindent \textbf{Cons:}

				Given all those nice pro's, preprocessors are still less well known than CSS.
				The different versions of preprocessors make it more difficult to find a whole development team that is already familiar with the language.
				In order for the developers to use whichever preprocessor they pick, this involves another thing they have to install to be able to get a website up and running.
				Installing a compiler also means that whatever code you write now relies on the compiler to be able to produce code that can be interpreted by browsers.


			\item{\textbf{Bootstrap}}

				\noindent \textbf{Pros:}

				Bootstrap is an open source and free framework developed by twitter with a huge amount of users and documentation.\cite{bootstrap}
				It has been "battle tested" on thousands of website implementations and has a small amount of issues.
				It includes HTML, JS and CSS components built in, which allows for development magnitudes faster than writing the code by hand.
				Bootstrap is designed with mobile layouts in mind, and has the feature that your website will be compatible with all sorts of screens right off the bat.
				Bootstrap has specified layouts, buttons, menus and icons that they want you to use which is limiting, but means a development team can produce something that looks good without needing anyone who understands graphic design.
				It is standardized and many developers know the framework, so maintenance and development by other teams is easy.

				\noindent \textbf{Cons:}

				Bootstrap is a really helpful but very big framework.
				There are tens of thousands of lines of code included in the project, and it also requires jQuery, which further inflates the size of the framework.
				This makes sites slower, heavier, and if you want to customize any elements in the page, you have to overwrite the CSS rules in Bootstrap.\cite{BootstrapProCon}
				This can be a painful process as it is a bad coding practice to put more code into a project to cancel out previous code.
				It leads to bugs and weird visual issues that would not show up with good development from scratch.
				With allowing the users to write less CSS, it requires that they offload page content, styling and functionality into the HTML, which can create bulky and illegible code for the content of your page.
				The drawback of having a framework make the stylistic decisions for you is that all Bootstrap websites end up looking the same.

		\end{itemize}


		\textbf{Conclusion}
		Preprocessors are generally considered the best option for projects that want the benefit of being able to create custom interfaces without having to deal with the drawbacks of writing raw CSS.
		Sass is one of the big three preprocessors, which offers a lot of flexibility in how you write the code, and really speeds up the development process.
		If for some reason the next group decides that they want to work just with CSS, they can always compile the CSS and then work with that from then on.\\



\subsubsection{Interactive Web Frameworks}

	\textbf{Introduction}
	There are many JavaScript frameworks out there for creating interactive websites.
	In fact, there are so many that the biggest issue becomes which one to choose, rather than whether to use it or not.
	They have built in functionality for a wide variety of things that are rather complicated to with native JavaScript.
	These JavaScript frameworks are so popular that nearly every major tech company has created their own and were kind enough to make them open source.

	\textbf{Critera}
	\begin{itemize}
		\item small
		\item fast
		\item well maintained as a framework
		\item make data manipulation easy for the developers
	\end{itemize}


	\textbf{Pros and cons for all JavaScript frameworks}
		\begin{itemize}

			\item{\textbf{Pros:}}
				\begin{itemize}
					\item Responsive websites - It is easy for the user to interact with components and get feedback.
					\item Much faster than developing it all from scratch.
					\item Frequently have the ability to extend the framework with plugins.
					\item Uses Model-View-Controller philosophy - This is a practice that helps developers keep a separation of states for data in the website. It leads to more controllable and better coding.
				\end{itemize}

			\item{\textbf{Cons:}}
				\begin{itemize}
					\item They all have a somewhat steep learning curve.
					\item There are so many of them it is harder to find a developer that is familiar with even just the popular frameworks
					\item If you are building a really tiny web app, the use of a JavaScript framework  can slow down the site
				\end{itemize}

		\end{itemize}



	\textbf{Technology}
		\begin{itemize}
			\item{\textbf{Angular}}
				\textbf{About:}

				AngularJS was originally developed in 2009 by Misko Hevery\cite{AngularIntroduction}.
				The original intent of the project to be an end-to-end tool that allowed web designers to interact with both the frontend and the backend.\cite{HistoryOfAngular}
				Hevery began working at Google and his project was noticed by the company and has been developed by Google employees since then.

				\noindent \textbf{Pros:}

				Angular was created early in the age of JavaScript frameworks and was one of the first systems of its kind.
				It is currently being maintained by Google, and having the backing of such a big company means that it will be sticking around.
				It has a huge user base and it is easy to find someone that has experience in developing with it.

				\noindent \textbf{Cons:}

				It is one of the oldest of its kind.
				It didn't have other frameworks come first to learn what mistakes not to make.
				As such, Angular has tried to reinvent itself several times and versioning of Angular is really confusing. Each version is so different it could be considered a different framework.
				Angular 1 is really slow\cite{SpeedReport} and can get messy really easily.

			\item{\textbf{React}}
				\textbf{About:}

				React allows developers to create large web-applications that use data and can change over time without reloading the page.
				It uses a similar ideology to Angular in use of the Model-View-Controller, but it is different in its organization.
				React was first deployed on Facebook's newsfeed in 2011 and later on Instagram.com in 2012.

				\noindent \textbf{Pros:}

				React is maintained by Facebook, which has the same benefits as Angular's backing by Google.
				The framework will be actively developed by many people, the documentation will be good, and the product reliable.
				Since React was built more recently than some of the older frameworks, it has some respectable benchmarks in terms of speed.\cite{SpeedReport}
				React can be used to build native apps as well, with the use of the framework React Native, web code can be used to write an app on iOS and Android.

				\noindent \textbf{Cons:}

				React has a fairly big learning curve and has a rather verbose syntax.
				React uses a system where the HTML is embedded in the JavaScript code.
				This makes development for people that don't already know the framework more difficult.
				Any language that is more verbose gives a greater potential for mistakes to be made.
				React is not a full framework.
				There are some features available in other frameworks like router or model management libraries that are not in React.
				A developer needs to be good at making decisions about what kind of frameworks should be added onto React to be able to do everything that other frameworks can do.


			\item{\textbf{Vue}}
				\textbf{About:}

				Vue is a progressive framework for building user interfaces.
				Vue is designed from the ground up to be incrementally adoptable.
				The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects.


				\textbf{Pros:}

				Vue is small at only half the size of Angular and React when running in a production environment.
				Vue is fast with speed benchmarks for simple tasks faster than almost every framework in almost every way measured.
				\footnote{This is not conclusive results that it the fastest out there, but its not something to dismiss.\cite{SpeedReport}}
				Vue is not very opinionated and allows flexibly in development.\cite{Vue}
				Because of its flexibility, it is easy to embed code in existing websites.
				Documentation for Vue is very good, as there is a dedicated core team working on making use of the framework easy and accessible.
				As such, the use of Vue has been trending up at a tremendous rate with trends in searches for vue.js is almost surpassing that of React\cite{vueVSreactSearches}

				\textbf{Cons:}

				Vue being a flexible framework allows programmers to make more mistakes and stylistic decisions that could make it more difficult for other developers to work on.

		\end{itemize}

	\textbf{Conclusion}
		Vue.js is a relatively new framework, but its popularity is still growing, the amount of features it offers is impressive and the size of the package is a major bonus.
		With less code comes less bugs.
		For the scope of this project, having a framework that is lightweight, easy to use, and has all the benefits of the bigger frameworks like Angular and React is a good choice.
		Its possible that the features that this framework offers might not be a requirement for the client, but if a JavaScript framework will help the project, then Vue.js is the best choice for it.\\


	\subsection{Hosting}

			\textbf{Introduction}
			Ninkasi needs to host it's data somehwere, either remotely using cloud hosting or locally using a server of some type.
			Below are the outlined options for small local servers or cloud hosting.
			Space available, scalability, cost, and complexity of each are explained.
			For a cheap, efficient, small server, our team has chosen to work with Raspberry Pi's.

			\textbf{Criteria}
			\begin{itemize}
				\item Scalable in terms of space, or if not scalable, ability to upgrade or cluster
				\item Low cost in the long run
				\item Easy for client to use after we leave this project
			\end{itemize}

		\textbf{Technology}
			\begin{itemize}
				\item{\textbf{Intel NUC}}
					The first option for hosting our data is the Intel NUC, or “Next Unit of Computing”.
					It has a low power consumption, idling at 8 watts and is barely audible (alphr). For the size, 5\textquotedblleft square by 1.5\textquotedblleft tall, the NUC is powerful \cite{IntelNUCReview}.
					Each version averages around 32 GB \cite{Intel}, but this is a fixed-size memory space.
					For a small company like Ninkasi, this would work well for the amount of data they are storing.
					If they wanted a scalable product in case their data became larger than 32 GB, that’s where NUC would fall short.
					Price wise, NUC's  fall between 274 and 500 dollars\cite{PCWorld}.
					There are also 4x4\textquotedblleft NUC boards that look very similar to Raspberry Pi's.
					These have 4-32 GB and cost from 120-575 dollars \cite{Intel}.
					\\ \\
					\textbf{Pros: Small and powerful for its size, quiet, good for a small server for a small business.}
					\\
					\textbf{Cons: Expensive, storage size limitations so not scalable.}


				\item{\textbf{Raspberry Pi}}
					Raspberry Pi's are the economically friendly option for hosting.
					The devices run between 5 and 35 dollars per unit and, although it is not the most common use of the technology, can be used as a small server\cite{CopaHost}.
					The raspberry pi itself only contains 1GB of space, and relies of a microSD card (which can hold upto 32GB and still be compatible with the device)\cite{CopaHost}.
					Raspberry Pi’s reliance on the SD card for I/O means the cost of using this technology is not limited to the board.
					This also requires setup that may be confusing for a non-technical user.
					On most version of raspberry pi boards there are 4 USB 2 ports, and 4 Pole stereo/composite video ports\cite{RaspberryPi}, so the device is very customizable.
					For small projects this is a perfect device, but would be a poor decision if the project increases dramatically in size.
					\\\\
					\textbf{Pros: Cheap and you get a lot for your money, server is on site.}
					\\
					\textbf{Cons: Cheap and not reliable, not enough storage space, setting it up and maintaining the hardware would be hard for someone with no little knowledge.}

				\item{\textbf{Cloud Hosting}}
					Cloud hosting is a way of hosting your data on a remote server through a company who charges you for that space.
					People with limited technical knowledge can use this service easily because you can be provided with a software environment that requires no setup or hardware\cite{InterRoute}.
					The system is very scalable, you pay for what you need and if you need more space you can buy more\cite{InterRoute}.
					Unlike the NUC or Raspberry Pi, this method of hosting isn't a one-time payment, you have to pay for the space you reserved each month\cite{TheBalance}.
					Some of the dangers of using cloud are that you are stuck as a “forever” customer if you can't convert your data from the host's system to another system\cite{TheBalance}.
					\\ \\
					\textbf{Pros: Reliable, scalable, easy to use with no technological knowledge, no hardware required.}
					\\
					\textbf{Cons: Have to pay each month, could potentially be stuck with a service if there is not a system for converting your data to anther service/system, poor customer service}

			\end{itemize}


			\textbf{Discussion}
				Raspberry Pi and NUC offer a lot of similar benefits for a small at-home server, but Raspberry Pi’s are much less expensive.
				NUC holds a similar amount of data as a Raspberry Pi combined with an SD card and is less complicated to set up and maintain.
				Cloud hosting is the most appealing for ease of use for our client, but as a monthly service the service provider will charge Ninkasi every month.
				Again, as Ninkasi is a successful company, this is not the most important consideration, but it is costlier in the long run.

			\textbf{Conclusion}
			For this project we will use cloud hosting because our client has specifically requested it.
			Raspberry Pi and NUC both have the benifit of a one time payment, but are more difficult for our client to maintain.
			They also are not scalable if the database were to expand as Ninkasi develops this data entry system.
			Cloud hosting is relatively inexpensive, is easy to use for our nontechnical client, and is scalable with the growth of the company.



	\subsection{Platform}
	\textbf{Introduction}
	The platform for our web servers will dictate the ease and speed of running concurrent processes, and what kind of stack we will be able to use.
	This section outlines the pros and cons of Nginx, Apache, and Express.js.
	The web servers we will use for our project are Apache, because they are fast, reliable, well documented and supported, and allow us to use Django and Python and relational databases.

	\textbf{Criteria}
		\begin{itemize}
			\item Allows for a relational database
			\item Easy to use and reliable
			\item Well document and supported
		\end{itemize}

	\textbf{Technology}
		\begin{itemize}
			\item{\textbf{Nginx}}
				NGINX is an open source server software that handles web serving as well as media streaming, caching, load balancing, and more\cite{NGINX}.
				NGINX is known for being very fast, especially around media streaming and serving static content\cite{NGINX}.
				NGINX is 2.5 times faster than Apache when serving static content and consumes less memory of the two when running the same amount of concurrent processes\cite{HostingAd}.
				If Ninkasi were serving a lot of static content and media streams, NGINX would be better as it is much faster for static content than Apache.
				Ninkasi just needs a simple database, so this is not relevant to our project.
				For our project, the advanced features of NGINX are appealing.
				\\ \\
				\textbf{Pros: Good security, faster and less space consuming for static content, many advanced features, handles load balancing well}
				\\
				\textbf{Cons: Most modules don't support dynamic loading, not good OS support for Windows}


			\item{\textbf{Apache}}
				Apache is part of the LAMP stack (Linux or other OS, Apache, MySQL, Php or similar lanugage) which is a traditional stack model\cite{UpWork}.
				It has 3 ways of request processing which scale differently.
				Apache has great OS support (better than NGINX which lacks good Windows support) and can run on many systems\cite{HostingAd}.
				It has good security and great documentation and supports dynamic loading well\cite{HostingAd}.
				\\ \\
				\textbf{Pros: Request processing 3 ways, handles load balancing well, excellent documentation, good security, supports dynamic laoding}
				\\
				\textbf{Cons: Slow for static content, doesn't scale well}


			\item{\textbf{Express}}
				Express.js is part of the MEAN stack (mongo-db, express.js, angular, node.js) stack and is a great choice for a modern platform if you want language uniformity and the ability to be mobile friendly\cite{UpWork}.
				Since we are not creating apps, the mobile ability is less important but the language uniformity would be helpful.
				That way regardless of what part of the stack the group is working on, they will know the language for all other sides of the stack.
				This system is also very flexible and offers lots of packages and plugins.
				It is an opensource product with a large community and lots of support\cite{JSSolutionsDev}.
				Express is an event  driven server, meaning it has a single threaded framework\cite{JSSolutionsDev}.
				Inexperienced developers may find this confusing if they aren't familiar with the callback nature of this type of server\cite{JSSolutionsDev}.
				Express works with Mongo-db which is a non-relational database. Express doesn’t allow for relational databases, which we need in our project.
				\\ \\
				\textbf{Pros: Flexible, modern, mobile friendly, uniform lanuage for full stack}
				\\
				\textbf{Cons: Confusing if unfamiliar with callback nature of server}

		\end{itemize}


		\textbf{Discussion}
		Our main interests in choosing server software are that it is compatible with a relational database, is easy to use and is well documented.
		NGINX and Apache allow us to use a relational database, while Express does not.
		Express is part of the MEAN stack, which means it’s language compatible and allows JavaScript, but we are limited in flexibility and have to use a NoSQL database.
		NGINX is faster than Apache while serving static content and also consumes less memory. That being said, the PHP runtime between the two types of server software are very similar\cite{HostingAd}.
		Since our website will not have a lot of static content and won’t be streaming any videos or audio, streaming speed doesn’t play a role in our decision.

		\textbf{Conclusion}
		Since Express doesn’t allow for a relational database, it will not be our server software.
		NGINX is faster than Apache, but we won’t be streaming media so this isn’t our main concern.
		Both NGINX and Apache are well documented, well supported, and easy to use.
		Apache has better support for Windows computers and many of Ninkasi’s computers are Windows, so this will be our choice.

	\subsection{Database Interaction Language}
		\textbf{Introduction}
			The choice of which language with which we will use to interact with our database is an important decision.
			We want our project to be very maintainable, both in the language's support and community, and the code we create with the language.
			For our project we don’t want to work with Php, because of previous experience in other areas and ease of use.
			We also want to use Apache so we can have a relational database and support for Windows OS.
			Because of these wants, we have chosen to use Django as our database interaction language.

		\textbf{Criteria}
		\begin{itemize}
			\item Works with the type of LAMP stack we are looking for
			\item Easy to code with
			\item Language that is popular and continually developed
		\end{itemize}

		\textbf{Technology}
			\begin{itemize}
				\item{\textbf{Ruby On Rails}}
					Ruby on Rails is a flexible and expressive language that has been at the foreground of database interaction languages in recent years.
					There are a lot of protocols for how to implement web features in Rails.
					Rails is opinionated, meaning most features have a standard way of being create\cite{Medium}.
					This has positives and negatives; making implementing forms or buttons standardized makes Rails easily maintainable, but also doesn't allow the coder as much flexibility in designing their own functions.
					Problems arise when Rails has no opinion on how to implement a web feature, then the style of \textquotedblleft one size fits all\textquotedblright in Rails doesn't work well\cite{Medium}.
					Rails is also very slow in comparison with Node or Php\cite{Medium}.
					For our purposes, Rails would be great for developing our project.
					Rails operates as part of LAMP stacks, which we need in order to implement a relational database.
					\\ \\
					\textbf{Pros: Maintainable, clean, protocols for everything}
					\\
					\textbf{Cons: A lot of abstraction (possibly too much depending on your purposes), not a defined way to do everything, way slow in comparison with other languages.}


				\item{\textbf{Node.js}}
					Node.js is a language you can use for full stack development\cite{Medium}.
					It allows Javascript to be run on the server side\cite{Medium}.
					Node is easy to learn, but unlike Rails, you have to build everything from the ground up\cite{NetGuru}.
					With little abstraction, you have total control of how features are implemented but development takes much longer.
					Node updates are often not backward compatible.
					Node can handle multiple requests at the same time and is way better at handling concurrent requests than Ruby\cite{Medium}.
					This means the app takes up less RAM and functions faster.
					Node has a high market demand, so for the intents of our project it would be very maintainable when we hand off our project to Ninkasi to expand.
					\\ \\
					\textbf{Pros: You can build a full stack with one language, easy to learn, strong community, actively developed language.}
					\\
					\textbf{Cons: You have to build every feature from the ground up, often backward incompatible updates.}


				\item{\textbf{PHP}}
					Php has the benefit of being around for a long time\cite{InfoWorldPhp}.
					This language has a lot of longevity and is constantly updated. It has a large open source community and lots of support, so maintainability would be high\cite{Medium}.
					The language is inconsistent and clunky, so this would diminish our development ease.
					There is a lack of abstraction, similar to Node.js, and often has repetitive code\cite{RailsApps}, something Rails would reduce.
					Php fits into the LAMP stack so we would be able to work with a relational database.
					\\ \\
					\textbf{Pros: Huge ecosystem and large open source community, always being updated, commonly used in industry for a long time.}
					\\
					\textbf{Cons: Very old, language is inconsistent, clunky, lack of abstraction.}


				\item{\textbf{Django}}
					Django is a python web framework that works similar to a LAMP framework.
					This stack is comprised of MySQL relational databases, Apache, and python\cite{Bitnami}.
					This is perfect for our need for relational database support. It allows for python front end development, which Connor is interested in.
					Similar to Node, Django is opinionated, having a self-proclaimed “batteries included” philosophy\cite{FullStackPython}.
					This means there is common functionality for building web apps. Authentication, URL routing, database scheme migrations, etc. are all included in Django framework and standardized\cite{FullStackPython}.
					The stability, performance, and community of Django have grown stronger in recent years\cite{FullStackPython}.
					\\ \\
					\textbf{Pros: Works with the stack we want, opinionated lanugage, easy to use, strong stability, performance and community }
					\\
					\textbf{Cons: Not as old as Php or Rails and there potentially less longevity}

			\end{itemize}

		\textbf{Discussion}
			Node.js is a easy to use, well supported language, but it is a part of the MEAN stack so we won’t be able to use it with a relational database.
			Rails and Php are both well documented and have strong open source communities online.
			Php is clunky, but has extreme longevity, so maintainability is high.
			Rails is opinionated, which makes development quick.
			This also makes implementations abstract and farther from the control of the developer, but this is standard in modern web development, so doesn't play a large role in our decision.
			Django is similarly structured, and is great if you want to use Python throughout the whole stack, but is newer than Rails and has a smaller community.

		\textbf{Conclusion}
			Node.js is a easy to use, well supported language, but it is a part of the MEAN stack so we won’t be able to use it with a relational database.
			Php is clunky and inconsistent, so we do not want to develop in Php when we can create similar results with Rails.
			Django is a good option for us, but because of our groups experience with Rails, that will be our choice.
			Rails is a modern, easy to use, abstract language that works with our LAMP-like stack.\\


	\subsection{System Peripherals}
		\textbf{Introduction}
				This is an overview of the various peripheral technologies our team may utilize to interface with the data management system.
				We will analyze the positive and negative impacts of creating a native mobile application, a native desktop application, or a web application.
				There are benefits and costs associated with each technology as described below.

		\textbf{Technology}
			\begin{itemize}

				\item{\textbf{Native Mobile Application}}
					\textbf{Summary:}
							Native mobile apps play an integral part in many business product lines.
							These applications are written in languages specific to devices they run on.
							These are generally recognized as good for sale to external customers\cite{SearchCloudOverview}.

					\textbf{Pros:}
							Native mobile applications have access to all capabilities of the smart phones on which they run.
							This includes push notifications which may be required in the data management system.
							Push notifications would allow brewers to receive updates on time-critical tasks without having to refresh the application.
							Since native mobile applications run on the specific device, this allows them to be used while not connected to the internet.
							It is unknown whether or not brewers will have good internet connection where they plan to use the application.
							Another benefit of running natively is that data can be stored directly on the device.
							This would ensure that data is never stored in a single, vulnerable space.
							Along these lines, running native mobile applications would reduce hosting needs to only data storage.
							When developing native mobile applications, most development kits come with "drag-and-drop" interface builders.
							This feature could reduce development time and increase maintainability once BrewHops team finishes.
							Finally, native mobile application interfaces run more quickly than mobile-web applications.
							Depending on how fast-pace the brewers' use of the application will be, this may reduce time spent in application.

					\textbf{Cons:}
							Native mobile applications can drastically increase the development timeline.
							Each device the application will run on must have its own version of the application.
							If Ninkasi uses multiple smartphones (E.G iPhone and Android), then each platform requires the application to be written in its native language.
							Learning new languages and platform specific standards will increase the time to project completion.
							After creation, deploying native mobile applications is more difficult than web-based applications.
							Native applications require download from the platform's app store or direct deployment from the developer.
							This may make it difficult to onboard new brewers or remove brewer's access.
							Once downloaded, any updates to the interface must be downloaded onto each device.
							Again, each update must be written for each hardware platform.
							Finally, if a brewer's device is lost or stolen then there is a potential security risk if Ninkasi data is stored on the device.


				\item{\textbf{Native Desktop Application}}
					\textbf{Summary:}
						Many of the same costs and benefits that arise with native mobile applications, come about with native desktop applications.

					\textbf{Pros:}
						When developing native desktop applications, applications have direct access to the host utilities.
						This is beneficial when many of these functions are needed in the application.
						Native desktop applications do not require internet connection to function.
						Depending on how information is stored, internet may still be required to access data.
						Since the application is running natively, data can be stored in the computer's memory.
						This can help create a fluid user experience.

					\textbf{Cons:}
						Similar to native mobile applications, native desktop applications require additional versions of the application written for each hardware platform supported.
						This may not be an issue if Ninkasi uses a single technology ecosystem; but it can make it difficult to switch platforms if there is ever a need.
						Native desktop applications must be downloaded onto each desktop computer that needs to run the program.
						This can increase the time needed to onboard new employees who require access to the software.
						Along with downloading the application onto each device, it'll become necessary to remove the application and all application data from the device when Ninkasi no longer uses the computer.


				\item{\textbf{Web Application}}
					\textbf{Summary:}
						Web applications are generally recognized as good for cross-platform internal usage\cite{SearchCloudOverview}.

					\textbf{Pros:}
						Web applications allow for each cross-platform functionality.
						Ninkasi brewers will access the system from their smartphones, desktops, and tablets.
						A web application will allow us to develop one application that exposes certain functionality based on the device used.
						These benefits also carry onward to different technology ecosystems.
						A single web application will run the same on an OSX device as it runs on a Windows device.
						When deploying web applications, nothing is downloaded since it runs in the browser.
						Web applications are also easily maintained and updated.
						They are written using common languages that every developer and many non-developers have seen before.
						It is possible to create push notifications in web sites\cite{GooglePushNotifications}.

					\textbf{Cons:}
						Unfortunately, since the application is hosted, brewers will need to maintain an internet connection to use the application.
						Without internet, there will be no way to work with live data from the database.
						Also, without native software, the application will not have access to hardware specific functions.
						Web applications also require static storage of the system along with database storage.
						Depending on how often individuals access the application, this may increase storage and processing requirements.
						Finally, web application interfaces tend to be slower than native applications\cite{LifeWireOverview}.

			\end{itemize}

			\textbf{Conclusion}
			To access and work with the data management system, there are several requirements. Listed below are the criteria along with an evaluation of each technology's ability to meet the requirement:\\


					\begin{center}
							\begin{tabular}{ |m{14em}|m{9em}|m{9em}|m{9em}|}
									\hline
											& Native Mobile & Native Desktop & Mobile Web \\

									\hline
											Accessable in Ninkasi cellar & X & & X \\

									\hline
											Accessible in Ninkasi offices & X & X & X \\

									\hline
											Cross Platform &  &  & X \\

									\hline
											Immediately deployable &  &  & X \\

									\hline
											Prior development experience &  &  & X \\

									\hline
											 Database connectable & X & X & X \\

									\hline
											Open source & & & X \\

									\hline
											Strong community & X & X & X \\

									\hline

							\end{tabular}
					\end{center}

			Based on the criteria for our system peripherals, we have decided to build a web application to access the data management system.\\


	\subsection{Data Storage}
		\textbf{Introduction}
		This is an overview of various types of databases. Databases will be used to store and access information that Ninkasi measures inside of each brewing vat.

		\textbf{Technology}
			\begin{itemize}
				\item{\textbf{SQL Database}}
					\textbf{Summary:}
						SQL Databases, also known as "relational" databases, are widely used to store highly \textit{structured} information\footnote{"Structured" information is data whose structure rarely, if ever, changes and is consistent between entities.}.

					\textbf{Pros:}
						Using SQL databases, it is easy to retrieve necessary information.
						SQL databases can use transactions which ensure that interactions with the database either complete fully or any changes are rolled back.
						SQL databases are structured.
						There exists many methodologies for normalization data to ensure it is stored efficiently\cite{TechwallaSQL}.
						SQL databases allow for multiple users to access information at the same time\cite{TechwallaSQLPros}.
						Database administrators can easily control operation permissions for each user in the system.
						Along with this, many tools exist to help developers optimize queries to access the database.

					\textbf{Cons:}
						Enterprise level SQL servers can be expensive to develop and maintain.
						Depending on the database, tables can have limits on their structure\cite{TechwallaSQLCons}.


				\item{\textbf{NoSQL Database}}
					\textbf{Summary:}
						NoSQL databases, also known as "non-relational" databases, are widely used to increase speed and decrease storage space of \textit{unstructured} information\footnote{"Unstructured" data is information that is not consistent between entities.}.

					\textbf{Pros:}
						There is no defined structure to the database.
						The structure is dynamic and can be updated without having to shutdown the database\cite{MongoDBProsCons}.
						Another benefit of NoSQL databases is their ability to handle "Big Data".
						There are tools available such as Hadoop that can handle the processing requirements of big data systems\cite{NoSQLProsCons}.
						Ninkasi produces high amounts of information that is monitored daily.
						Ideally, the client would prefer to track this information more frequently, which would lead to larger amounts of information.
						Also, "NoSQL databases typically use clusters of cheap commodity servers to manage the exploding data and transaction volumes."\cite{NoSQLProsCons}.
						This may be essential if the BrewHops team uses Raspberry Pis or Intel Nucs to host system information.


					\textbf{Cons:}
						While there are benefits to using a NoSQL database, there are also drawbacks.
						NoSQL technologies are typically open-source projects that do not have the support and resources that major relational database management systems have\cite{NoSQLProsCons}.
						There are still several security issues associated with NoSQL databases\cite{NoSQLSecurityIssues}.
						There is no guarantee data consistency when using NoSQL databases\cite{ChannelFutures}.
						They use "eventual consistency" which implies times of inconsistency.
						Some NoSQL databases do not automatically shard data to properly spread data across clusters\cite{ChannelFutures}.
						This will only be an issue if Ninkasi data needs will require multiple nodes.


				\item{\textbf{Flat File Database}}
					\textbf{Summary:}
						Flat file databases are commonly used to store configuration settings for software systems.

					\textbf{Pros:}
						Incredibly simple to set up, literally just a file.
						Easily read since there is a standard structure using delimeters or line length.

					\textbf{Cons:}
						Duplicate data, any new entries require a new row
						No transactions
						Not usually accessed via network since they're offline entities that are part of the operating system\cite{Techwalla}.
						"... a flat file database is disadvantageous to a network user, who is accessing a multi-access, multi-tasking relational online databse which can be viewed from many different aspects." \cite{Techwalla}.
						"... not encountered as 'databases', but more as configuration files..." \cite{Techwalla}.

			\end{itemize}


			\textbf{Conclusion}
					Listed below are the requirements of the database system that will be used in this data management system.

					\begin{center}
							\begin{tabular}{| m{15em} | m{10em} | m{10em} | m{10em} |}
									\hline
											& SQL Database & NoSQL Database & Flat Files \\

									\hline
											Minimal data duplication & X & X & \\

									\hline
											Data Integrity & X &  &  \\

									\hline
											Data retrieval reliability & X &  & X \\

									\hline
											Strong Documentation & X & X & X \\

									\hline
											Free to use & X\footnote{There are certain versions of SQL databases that are free.} & X & X \\

									\hline
							\end{tabular}
					\end{center}

					Based on the criteria, we will store our data in a relational SQL database.\\

	\subsection{Task Runners and Module Bundlers}
			\textbf{Introduction}
					This section gives an overview on various task runners and module bundlers.
					It is common practice in web development to use small open source packages/libraries to complete specific tasks.
					Each of these libraries comes with dependencies along with other tasks that need to be handled before deployment.
					Task runners and module bundlers take care of these dependencies and performing routine pre-deployment operations.

		\textbf{Technology}
			\begin{itemize}

				\item{\textbf{Grunt}}
					\textbf{Summary:}
						Grunt is a tool that allows "front-end developers to run predefined reptitive tasks"\cite{TaskRunners}. This is commonly used in enterprise level web applications.

					\textbf{Pros:}
						Grunt is built on top of NodeJS which makes it integrate easily with other Node based applications.
						Grunt is the oldest tool of its kind and has a strong community behind it.
						This also ensures the stability and further development of Grunt.
						Along with this, Grunt has thousands of modules available for developers to use.
						An important difference between Grunt and other task runners is its focus on configuration over code.
						To make Grunt work for you, you configure the tasks it completes.

					\textbf{Cons:}
						There are some downsides to Grunt as well.
						Developers reuse configuration objects to automate their tasks.
						This can lead to bloated Grunt scripts that are not maintainable\cite{TaskRunners}.


				\item{\textbf{Gulp}}
					\textbf{Summary:}
						Gulp is a task runner that requires developers to write code to automate repetitive tasks\cite{TaskRunners}.
						Gulp was developed after Grunt.

					\textbf{Pros:}
						A major benefit of Gulp is its use of Javascript functions to define when and how tasks should execute.
						Another benefit is that Gulp scripts tend to run more quickly than Grunt configuration\cite{GulpGruntSpeed}.
						This is possible ecause of Gulp's "stream usage and in-memory operations"\cite{TaskRunners}.

					\textbf{Cons:}
						Gulp relies on several paradigms that are not common practice in other areas of development.
						These paradigms can make it difficult for new developers to create efficently create automation scripts.
						There is no reason to use a task runner on small projects if the developer can quickly and easily perform the tasks by hand.


				\item{\textbf{WebPack}}
					\textbf{Summary:}
						WebPack differs from Grunt and Gulp in that it is a module bundler.
						It takes various modules that all have dependencies and bundles them together in a way that reduces redundancy\cite{WebPack}.
						It creates a dependency graph of all modules needed in your system and consolidates them into individual bundles\cite{WebPack}.

					\textbf{Pros:}
						The major benefit of using WebPack is its ability to reduce software size through its consolidation method of individual modules.
						Another benefit of WebPack is using hot-reloading to more efficiently develop the frontend of an application\cite{TaskRunners}.
						The biggest pro is that Vue.js has a command line interface designed to ease development with Vue components.
						This command line interface uses Webpack as the task runner.

					\textbf{Cons:}
						Finally, the main difficulty with WebPack is it can be difficult to configure at first and there exists a learning curve to its technology\cite{TaskRunners}.
						WebPack is a technology that is extremely useful for major enterprise level applications, but tends to be over-powered for small applications.

			\end{itemize}


			\textbf{Conclusion}
					Listed below are the various criteria needed in a task runner and module bundling system.

			\begin{center}
							\begin{tabular}{| m{15em} | m{10em} | m{10em} | m{10em} |}
									\hline
											& Grunt & Gulp & WebPack \\

									\hline
											Software size reduction & X & X & X \\

									\hline
											Automatable for deployment & X & X & X \\

									\hline
											Easy to learn &  & X &  \\

									\hline
											Strong community & X & X & X \\

									\hline
											Strong Documentation & X & X & X \\

									\hline
											Free to use & X & X & X \\

									\hline
											Integrates well with Vue.js &  &  & X \\

									\hline
							\end{tabular}
					\end{center}

					Based on the criteria, we will be using Webpack to automate repetitive tasks.\\





\section{Weekly Blog Posts}
	\subsection{Connor Christensen}
	\input{connorBlog}
	\subsection{Lily Shellhammer}
	\input{lilyBlog}
	\subsection{William Buffum}
	\input{billyBlog}
\section{Final Poster}
\includepdf{team10.pdf}
\section{Project Documentation}
	\subsection{How does your project work?}
		\subsubsection{Front End}
		Our projects front end consists of Vue.js, an object oriented javascript framework, CSS and HTML.
		All of the CSS, with the exception of C3 charts, is written by Connor, our front end designer.
		We used vue-router to change pages, each loading a different component of the site.
		When a user logs in, if their username and password are validated, they are routed to the home page which displays tank monitoring and form entry.
		On the home page they can enter information on an existing tank, make a new batch, or enter information on an exisiting batch.
		Depending on if their device is a mobile phone, tablet, or desktop, tank monitoring or the measurement forms will be shown, or both depending on size of screen.
		Tank monitoring is displayed on the home page.
		The tanks are represented with divs that display information about each tank.
		On the back end, the tank, batch, batch contents, and actions tables are looped through to find the most recent batch associated with a tank and the corresponding actions.
		If the user clicks on a 'tank', they are routed to a page that displays the information for that tank including identification infomration, the most recent measurement readings, and the actions needed.
		There they can also see measurement points over time displayed in charts generated using C3.
		If the user is an admin, the can click "Admin Login" at the login page which will direct them to the admin page.
		There they can create new tanks, users, recipes, and actions and update existing tanks.
\subsubsection{Back End}
	\subsection{How does one install your software, if any?}
	Source code given upon request.
	Below are installation instructions for hosting on personal Mac computer (assumes homebrew, rbenv, postgres 10.1, ruby 2.4.1 installed already):
	\begin{itemize}
		\item Type 'rbenv install 2.4.1' - install ruby version 2.4.1
		\item Type 'rbenv global 2.4.1' - switch to the newly installed version
		\item Type 'gem install rails' - install rails
		\item Type 'bundle install' - install the required gems
		\item Type 'rake db:create' - create the database
		\item Type 'rake db:migrate' - migrate the schema from rails into the database
		\item Type 'rails server' - start up the server
		\item Visit the website by going to your localhost on port 3000
	\end{itemize}

	\subsection{How does one run it?}
	Vist 'https://ninkasi-server.herokuapp.com/' to access the backend endpoints directly.
	Or visit 'localhost:3000' in your browser if running locally.

	\subsection{Are there any special hardware, OS, or runtime requirements to run your software?}
	Any system that can run Ruby on Rails version 5.1.4, Ruby version 2.4.1, and Postgres version 10.1 will be able to host the server.

	\subsection{Any user guides, API documentation, etc.}
	\textbf{API Structure/Use}
	\begin{itemize}
		\item \textbf{Batches}
			\begin{itemize}
				\item 'GET /batches' - shows list of all current brews
				\item 'POST /batches' - create new batch
				\item 'GET /batches/:id' - shows batch with specific ID
				\item 'PUT /batches/:id' - update batch with specific ID
				\item 'DELETE /batches/:id' - delete batch with specific ID
			\end{itemize}

		\item \textbf{BatchContentsVersions}
			\begin{itemize}
				\item 'GET /batch\_contents\_version' - shows a list of all batch readings
				\item 'POST /batch\_contents\_version' - creates a new version based on daily readings
				\item 'GET  /batch\_contents\_version/:id' - shows the version history for a particular batch
				\item 'DELETE /batch\_contents\_version/:id' - deletes the history for a particular batch
			\end{itemize}

		\item \textbf{Employees}
			\begin{itemize}
				\item 'GET /employees' - shows list of all current employees
				\item 'POST /employees' - create a ew employee
				\item 'GET /employees/:id' - show employee with specific ID
				\item 'PUT /employees/:id' - update employee with specific ID
				\item 'DELETE /employees/:id' - delete employee with specific ID
			\end{itemize}

		\item \textbf{Actions}
			\begin{itemize}
				\item 'GET /actions' - show list of possible actions
				\item 'POST /actions' - create new action
				\item 'GET /actions/:id' - show details about a specific action
				\item 'PUT /actions/:id' - update details about a specific action
				\item 'DELETE /actions/:id' - delete action from system
			\end{itemize}

		\item \textbf{Recipes}
			\begin{itemize}
				\item 'GET /recipes' - show list of all recipes
				\item 'POST /recipes' - add new recipe to the system
				\item 'GET /recipes/:id' - show detailed information on a specific recipe
				\item 'PUT /recipes/:id' - update information on a specific recipe
				\item 'DELETE /recipes/:id' - delete specific recipe from the system
			\end{itemize}

		\item \textbf{Tanks}
			\begin{itemize}
				\item 'GET /tanks' - show list of all tanks
				\item 'POST /tanks' - add new tank to the system
				\item 'GET /tanks/:id' - show information on a specific tank
				\item 'PUT /tanks/:id' - update information on a specific tank
				\item 'DELETE /tanks/:id' - delete specific tank from the system
			\end{itemize}

		\item \textbf{Tasks}
			\begin{itemize}
				\item 'GET /tasks' - show list of all current tasks in the system
				\item 'POST /tasks' - add a new task to the system
				\item 'GET /tasks/:id' - show detailed information on a specific task
				\item 'PUT /tasks/:id' - update information on a specific task
				\item 'DELETE /tasks/:id' - delete specific task from the system
			\end{itemize}
	\end{itemize}

\section{Recommended Technical Resources}
	\subsection{Vue.js}
	A fast and lightweight JavaScript framework for making interactive web apps
	\begin{itemize}
		\item The official Vue.js resource: \hyperlink{https://vuejs.org/v2/api/}{https://vuejs.org/v2/api/}
		\item Command line interface: \hyperlink{https://github.com/vuejs/vue-cli}{https://github.com/vuejs/vue-cli}
		\item Routing for single page apps: \hyperlink{https://github.com/vuejs/vue-router}{https://github.com/vuejs/vue-router}
		\item Webpack loader: \hyperlink{https://github.com/vuejs/vue-loader}{https://github.com/vuejs/vue-loader}
		\item Vue-Resource for http requests: \hyperlink{}{}
	\end{itemize}
	\subsection{JavaScript tools}
	Additional resources for easier app development
	\begin{itemize}
		\item Crypto-js for encrypting passwords: \hyperlink{https://www.npmjs.com/package/crypto-js}{https://www.npmjs.com/package/crypto-js}
		\item js-cookie for setting cookies: \hyperlink{https://github.com/js-cookie/js-cookie}{https://github.com/js-cookie/js-cookie}
	\end{itemize}
	\subsection{c3.js}
	Interactive charts and graphs for data visualization
	\begin{itemize}
		\item c3.js: \hyperlink{http://c3js.org/}{http://c3js.org/}
		\item d3.js: \hyperlink{https://d3js.org/}{https://d3js.org/}
	\end{itemize}
	\subsection{Stylus}
	A beautiful and powerful language that compiles down into CSS
	\begin{itemize}
		\item The offical page for Stylus: \hyperlink{http://stylus-lang.com/}{http://stylus-lang.com/}
	\end{itemize}
	\subsection{Ruby on Rails}
	A ruby based framework that manages database interactions and REST API construction
	\begin{itemize}
		\item The official page for Ruby on Rails: \hyperlink{https://rubyonrails.org/}{https://rubyonrails.org/}
	\end{itemize}
	\subsection{Heroku}
	An easy to use web hosting location for your back-end code
	\begin{itemize}
		\item The offical page for Heroku: \hyperlink{https://www.heroku.com/}{https://www.heroku.com/}
	\end{itemize}
	\subsection{Webpack}
	A task runner for more efficient development environments
	\begin{itemize}
		\item See {\it Vue command line interface}
		\item The offical page for Webpack: \hyperlink{https://webpack.js.org/}{https://webpack.js.org/}
	\end{itemize}
\section{Conclusions}
	\subsection{Connor Christensen}
		\subsubsection{What technical information did you learn?}

		I had played with Vue.js before, but spending a year working on this project gave me a much better understanding of Vue.js.
		The research phase of the project also gave me a better understanding about how Vue.js and other JavaScript frameworks compare.
		I had never worked with Ruby on Rails before, and helping Billy with his section of the project gave me a general sense of how the techonoly works.
		I made a few fixes during the term when Billy was occupied and Lily and I needed something to have a bug with the database resolved before we could continue work.

		\subsubsection{What non-technical information did you learn?}

		I learned how to do agile development with GitHub, which has been a very usefull skill in and out of the Capstone course.
		This class has been known to make friendships difficult, and there have been a few frustrations across the course, but I am happy to have our group be proof that it is not always the case.

		\subsubsection{What have you learned about project work?}

		I got some experience being the lead in my own field without anything standing in my way.
		I have worked some jobs before where I had limitations with what kind of software I could use, how I could use it, and which buttons I was allowed to press.
		In this project, the client gave me and my teamates the freedom to choose what is best for the project.

		\subsubsection{What have you learned about project management?}

		I have done a majority of the project management, and it has been difficult, but a good experience.
		There is a fight between programmers over tabs vs spaces, but the correct answer is to use whichever is alreay in place in the project.
		I have found that the more hacks and temporary fixes are put in place in a project, the harder it becomes to manage.
		In the future I need to be a little more set on enforcing good programming habits.
		I'm glad to have already learned from the developer side that having blocking issues is really bad for development, so I was fortunate enough to focus on removing blocking issues as quickly as I could.

		\subsubsection{What have you learned about working in teams?}

		Apart from the project management lessons, all team work can be done effectively with competent workers, open communication and comprimise.

		\subsubsection{If you could do it all over, what would you do differently?}

		Our team had a really hard time getting Ruby on Rails working the way we wanted to.
		Despite it being sold as the solution for the very problem we had, it ended up getting in our way much more than helping.
		With a faster and easier development on the back end, a lot of the work on the front end could have been alleviated.

	\subsection{Lily Shellhammer}
		\subsubsection{What technical information did you learn?}
		I know a lot more about web development and javascript now and feel comfortable using Vue.js and working on web based projects.
		Early on I learned how all the pieces of the stack interact.
		Toward the end of the project I was able to harness the power of Vue and javascript to complete some trickier tasks that I would have had no idea how to approach at the beginning of fall term.
		I am also way better at using Github now.
		I learned to create lots of issues to track what I needed to do and what I had done.
		This helped with documentation as well as chunking up the project into easier parts and coordinating with the rest of the team better.
		\subsubsection{What non-technical information did you learn?}
		Communication about expectations is really important in long term projects.
		Our team had great communication from the beginning, but in busy or stressful times, we sometimes didn't communicate the full extent of our frustration with one another.
		We ended up having open and honest dialogue, but without touching base every few days, we would lose that contact during those times of stress.
		My organization skills surrounding large projects and code banks definitely improved, and is already helping me in my research internship.
		\subsubsection{What have you learned about project work?}
		The whole team did a great job working together, and seeing that made me realize how important it is to have a supportive, motivated team surrounding you.
	  If your group wants to be successful, then you don't have to worry about pushing everyone in that direction, you're all already going there.
		Whenever someone in our group was lagging, if we talked to them seriously about their part, they would step up.
		\subsubsection{What have you learned about project management?}
		I learned that a leader can make or break your project.
		Connor did an amazing job spearheading the team and was organized and assertive without being demanding or unreasonable.
		We all had small roles of management, from being the group expert on a certain topic to being the point of contact for the client.
		If the management is clear about the expectations of everyone else, the team works smoothly.
		\subsubsection{What have you learned about working in teams?}
		It's important to keep track of everyone elses timelines.
		If you get too focused on your own work you lose sight of where you are with respect to the group.
		It's also important to touch base on your timeline, struggles, and progress often, otherwise you could be struggling on something that is less important or has already been solved.
		\subsubsection{If you could do it all over, what would you do differently?}
		I would dive in deeper to Vue in the first few weeks of winter term.
		I sort of slid into my role rather than immersing myself in it and had a lot of work to do later in winter term because of that.
		At the beginning of the term I should have asked more about organization and the system we were using.
		If I had understood the role of issues and sprints a little better I would have been more motivated to learn how to utilize them, but I didn't fully grasp them when I started.
		Honestly, my group was pretty stellar so there isn't anything different I would have done about them, just a few improvements on my end.

	\subsection{William Buffum}
		\subsubsection{What technical information did you learn?}
		Throughout the year, I've learned a lot more about proper REST API design.
		Coming into this project, I thought that RESTful design was synonymous with creating the CRUD (Create, Read, Update, Delete) operation for each of the database tables.
		After my initial implementation of the backend api, it was soon apparent that many things could be designed in a more efficient way for the client side application.

		\subsubsection{What non-technical information did you learn?}
		I learned a lot about Ninkasi's brewing system and how small-medium size breweries operate.
		I also learned a lot about communicating with clients and how important being able to translate technical information into non-technical terms is.
		Finally, I learned the importance of documentation.
		Lily was struggling to use the backend of the application because my endpoints were not well documented.
		Fixing that documentation and better communicating how to use my api, significantly helped her complete the front end of the application.

		\subsubsection{What have you learned about project work?}
		Project work requires a lot of communication.
		When team members run head-into problems and try to solve them before communicating with other team members, it can significantly slow down the development process.
		Also, it's important to stay on top of your work-load.
		If two individuals are working on different time-scales, then it results in some people becoming blocked, and others being forced to do a lot of work when they did not expect to.

		\subsubsection{What have you learned about project management?}
		I learned how important it is to track your progress and to version control everything you create.
		When you track problems, it helps communicate to other team members of the project and prevent blocking issues from arising.

		\subsubsection{What have you learned about working in teams?}
		Communication is key.
		If you can't communicate with your team, then you're not going to successfully deliver your project.

		\subsubsection{If you could do it all over, what would you do differently?}
		I would select a different technology stack on the back-end.
		I would encourage team members to better communicate expectations during each phase of the project.

\section{Appendix 1: Essential Code Listings}

\begin{figure}[H]
	\centering
	\includegraphics[width=7in]{./code/device_check.png}
	\caption{An if statement that checks to see if the device it is running on is a mobile or tablet}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=.3]{./code/breakpoints.png}
	\caption{Custom sylus code that defines breakpoints at common screen sizes from desktop to small mobile devices}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=.3]{./code/breakpoints_example.png}
	\caption{An example of the breakpoints code being used to define how the page will react when sized greater than a desktop device or less than the size of a tablet}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=.3]{./code/routes_imports.png}
	\caption{The process of importing all the Vue components into the routes page so the router knows where to send the user to when they hit a certain path}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=.3]{./code/routes.png}
	\caption{The mapping of url paths to components}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=.3]{./code/components.png}
	\caption{A use of chart components on the tank-info page. Each chart has the dates and values passed into the component as a prop}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=.3]{./code/mixins.png}
	\caption{Some additional custom Stylus functions to be used throughout the program to make the code easier to read and more modular}
\end{figure}

\section{Appendix 2: Additional Items}


\end{document}
